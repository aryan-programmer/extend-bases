{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-ignore\nimport * as flatMap from \"array.prototype.flatmap\";\n// @ts-ignore\nimport * as ownKeys from \"reflect.ownkeys\";\nimport { classWithoutCallParentConstructor } from 'class-without-call-parent-constructor';\n\nif (typeof Reflect.ownKeys === \"undefined\") {\n\townKeys.shim();\n}\n\nif (typeof Array.prototype.flatMap === \"undefined\") {\n\tflatMap.shim();\n}\n\nfunction onlyUnique<T> (value: T, index: number, self: T[]) {\n\treturn self.indexOf(value) === index;\n}\n\n/**\n * The type of the constructor of an object.\n */\ntype Ctor = new(...params: any[]) => any;\n\ntype AnyInstancesOf<T extends Ctor[]> = InstanceType<T[number]>;\n\n/**\n * Black magic.\n *\n * Note: Works only in one way.\n *\n * @internal\n */\ntype UnionToIntersection<U> =\n\t(U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\n/**\n * Specifies that the array contains all the instances of specified constructors in order.\n */\ntype InstancesArray<Ts extends Ctor[]> = {\n\t[I in keyof Ts]: Ts[I] extends Ctor ? InstanceType<Ts[I]> : never;\n} & Array<InstanceType<Ts[number]>>;\n\nconst SymbolBases = Symbol.for('extend-bases#bases');\n\n/**\n * Specifies that the object has an array containing instances of all of the bases.\n */\ntype HasBasesArray<TBases extends Ctor[]> = {\n\treadonly [SymbolBases]: InstancesArray<TBases>\n}\n\n/**\n * Specifies that the object is an intersection of all of the bases, and has an array containing all of the base instances.\n */\ntype HasBases<TBases extends Ctor[]> =\n\tUnionToIntersection<AnyInstancesOf<TBases>> &\n\tHasBasesArray<TBases>;\n\nfunction extendStatics (derived: any, base: any): any {\n\tfor (const p of Reflect.ownKeys(base)) {\n\t\tif (p === \"length\" || p === \"prototype\" || p === \"name\") {\n\t\t\tcontinue;\n\t\t}\n\t\t// Avoid bugs when hasOwnProperty is shadowed\n\t\tif (Object.prototype.hasOwnProperty.call(base, p)) {\n\t\t\tderived[p] = base[p];\n\t\t}\n\t}\n}\n\nfunction setPrototypeToProxy<TBases extends Ctor[]> (\n\tself: (...args: any[]) => void,\n\tbaseClasses: TBases\n) {\n\tconst proto = self.prototype;\n\tfor (let i = baseClasses.length - 1; i >= 0; i--) {\n\t\tconst basePrototype = baseClasses[i].prototype;\n\t\textendStatics(self, baseClasses[i]);\n\t\tfor (const nextKey of Reflect.ownKeys(basePrototype)) {\n\t\t\t// Avoid bugs when hasOwnProperty is shadowed\n\t\t\tif (nextKey !== SymbolBases && Object.prototype.hasOwnProperty.call(basePrototype, nextKey)) {\n\t\t\t\tconst val = basePrototype[nextKey];\n\t\t\t\t// Only transfer functions\n\t\t\t\tif (nextKey !== \"constructor\" && typeof val === \"function\") {\n\t\t\t\t\t// Make sure that the function is only called on the specific base.\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tproto[nextKey] = function (this: HasBases<TBases>, ...args: any[]): any {\n\t\t\t\t\t\treturn val.apply(this[SymbolBases][i], args);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// proto.constructor = self;\n\t// Object.freeze(proto);\n// \tself.prototype = proto;\n\treturn self as unknown as new() => object;\n}\n\n/**\n * Returns a class which when \"inherits\" from all of the base classes.\n *\n * This function isolates the method calls on the bases, so if any of the 2 bases share a property or method with the same name then, they will not affect each other.\n *\n * When you access a property or method directly on `this` and not on `this[SymbolBases]`, and it doesn't exist on the `this` instance, then the first base class with the method/property will be the one given precedence and its method/property will be the one given.\n *\n * The returned class must be initialized with the <i><b>instances</b></i> of each of the respective base classes\n *\n * Note: There is a caveat in setting properties, if you directly set a property in the constructor and the super class has the same property name then it will be overwritten, and the super class will refer to the same property, and things may break.\n * This is not due to this library, this is due to the inherent dynamic nature of JavaScript.\n * But, this library isolates the derived and base classes, ie prevents collision of their properties and methods.\n * Thus, this problem can be avoided by using the <code>defineProperties</code> method from this library, if you use the <code>[SymbolBases]</code> methods as well.\n * @param baseClasses The base classes to be inherited.\n * @return A constructor taking in the *instances* of the base classes.\n *\n * @example\n * class Activatable {\n *     val: boolean;\n *\n *     constructor (val: boolean) {\n *         this.val = val;\n *     }\n *\n *     activate () {\n *         this.val = true;\n *     }\n *\n *     deactivate () {\n *         this.val = false;\n *     }\n *\n *     get (): boolean {\n *         return this.val;\n *     }\n * }\n *\n * class Accumulator {\n *     val: number;\n *\n *     constructor (result: number) {\n *         this.val = result;\n *     }\n *\n *     add (val: number) {\n *         this.val += val;\n *     }\n *\n *     get (): number {\n *         return this.val;\n *     }\n * }\n *\n * // Now let’s declare a new class inheriting from both of the classes:\n * class NewClass extends bases(Activatable, Accumulator) {\n *     constructor () {\n *         // To initialize the bases create a new instance of them and pass them to the constructor of the super class, now you will no longer need the `super` keyword.\n *         super(\n *             new Activatable(true),\n *             new Accumulator(0),\n *         );\n *     }\n *\n *     getBoth () {\n *         // To get a specific base use `this[SymbolBases][index]` where index is the index of the base as given in the bases function.\n *         return `Gotten: ${this[SymbolBases][0].get()} ${this[SymbolBases][1].get()}`\n *     }\n * }\n *\n * const n = new NewClass();\n * console.log(n.val); // true: The base given first is given preference.\n * console.log(n.get()); // true: The base given first is given preference, of course.\n * n.add(10);\n * n.deactivate();\n * console.log(n.val, n[SymbolBases][1].val); // false 10: The [SymbolBases] are isolated, one can't affect the other, not directly that is.\n */\nfunction bases<TBases extends Ctor[]> (...baseClasses: TBases):\n\tnew (...baseInstances: InstancesArray<TBases>) => HasBases<TBases> {\n\ttype BaseInstances = InstancesArray<TBases>;\n\ttype Self = HasBases<TBases>;\n\n\tclass Self2 extends classWithoutCallParentConstructor(baseClasses[0]) {\n\n\t\tconstructor (...baseInstances: BaseInstances) {\n\t\t\tsuper();\n\n\t\t\t/*\n\t\t\tReflect.defineProperty(this, 'bases', {\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: baseInstances,\n\t\t\t\twritable: false,\n\t\t\t});\n\t\t\t */\n\n\t\t\tReflect.defineProperty(this, SymbolBases, {\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: baseInstances,\n\t\t\t\twritable: false,\n\t\t\t});\n\n\t\t\treturn new Proxy(this as any as Self, {\n\n\t\t\t\tisExtensible (target: Self): boolean {\n\t\t\t\t\treturn Reflect.isExtensible(target) && target[SymbolBases].every(Reflect.isExtensible);\n\t\t\t\t},\n\t\t\t\tpreventExtensions (target: Self): boolean {\n\t\t\t\t\treturn Reflect.preventExtensions(target) && target[SymbolBases].every(Reflect.preventExtensions);\n\t\t\t\t},\n\t\t\t\tgetOwnPropertyDescriptor (target: Self, p: string | number | symbol): PropertyDescriptor | undefined {\n\t\t\t\t\tlet pd: PropertyDescriptor | undefined = Reflect.getOwnPropertyDescriptor(target, p);\n\t\t\t\t\tfor (const base of target[SymbolBases]) {\n\t\t\t\t\t\tif (pd != null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpd = Reflect.getOwnPropertyDescriptor(base, p);\n\t\t\t\t\t}\n\t\t\t\t\treturn pd;\n\t\t\t\t},\n\t\t\t\thas (target: Self, p: string | number | symbol): boolean {\n\t\t\t\t\treturn Reflect.has(target, p) || target[SymbolBases].some(base => Reflect.has(base, p));\n\t\t\t\t},\n\t\t\t\tget (target: Self, p: string | number | symbol): any {\n\t\t\t\t\tif (p in target) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn target[p];\n\t\t\t\t\t}\n\t\t\t\t\tfor (const base of target[SymbolBases]) {\n\t\t\t\t\t\tif (p in base) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn base[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn target[p];\n\t\t\t\t},\n\t\t\t\tset (target: Self, p: string | number | symbol, value: any): boolean {\n\t\t\t\t\tif (p in target) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\ttarget[p] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const base of target[SymbolBases]) {\n\t\t\t\t\t\tif (p in base) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tbase[p] = value;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\ttarget[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tdeleteProperty (target: Self, p: string | number | symbol): boolean {\n\t\t\t\t\tif (p in target) {\n\t\t\t\t\t\treturn Reflect.deleteProperty(target, p);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const base of target[SymbolBases]) {\n\t\t\t\t\t\tif (p in base) {\n\t\t\t\t\t\t\treturn Reflect.deleteProperty(base, p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Reflect.deleteProperty(target, p);\n\t\t\t\t},\n\t\t\t\tenumerate (target: Self): PropertyKey[] {\n\t\t\t\t\treturn Reflect.ownKeys(target).concat(target[SymbolBases].flatMap(Reflect.ownKeys)).filter(onlyUnique);\n\t\t\t\t},\n\t\t\t\t// @ts-ignore\n\t\t\t\townKeys (target: Self): PropertyKey[] {\n\t\t\t\t\treturn Reflect.ownKeys(target).concat(target[SymbolBases].flatMap(Reflect.ownKeys)).filter(onlyUnique);\n\t\t\t\t},\n\t\t\t\t// If you want to define a property then you certainly don't want it to be on the base class.\n\t\t\t\tdefineProperty (target: Self, p: string | number | symbol, attributes: PropertyDescriptor): boolean {\n\t\t\t\t\treturn Reflect.defineProperty(target, p, attributes);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tsetPrototypeToProxy(Self2 as any, baseClasses);\n\n\treturn Self2 as unknown as new(...baseInstances: BaseInstances) => HasBases<TBases>;\n}\n\n/**\n * Defines the properties on the given object, the key represents the name of the property and the value as the, well, value.\n * Moreover, if the property name if prefixed with `readonly` then the property will be set to be readonly, ie non-writable, ie any attempts to edit it in strict mode will fail with a `TypeError`.\n *\n * Use this function to set the properties of the objects inheriting from multiple base classes.\n *\n * @param v The object on which to define the properties\n * @param props A object with the keys as the property names and the values as the values of the properties.\n *\n * @example\n * // In the constructor\n * defineProperties(this, {\n *     <prop>: <value>, // Define a property on `this` with the name <prop> and value <value>\n *     \"readonly <>\": <value>, // Define a readonly property on `this` with the name <prop> and value <value>, readonly ie any attempts to edit it in strict mode will fail with a TypeError.\n * });\n */\nfunction defineProperties<T extends object> (v: T, props: { [key: string]: any }) {\n\tfor (const prop of Reflect.ownKeys(props)) {\n\t\tif (typeof prop !== \"string\") {\n\t\t\tcontinue;\n\t\t}\n\t\tlet propName = prop;\n\t\tlet isWritable = true;\n\t\tif (prop.startsWith(\"readonly \")) {\n\t\t\tisWritable = false;\n\t\t\tpropName = prop.slice(9);\n\t\t}\n\n\t\tReflect.defineProperty(v, propName, {\n\t\t\tvalue: props[prop],\n\t\t\twritable: isWritable,\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t})\n\t}\n}\n\n/**\n * Checks if the value `v` is an instance of the class `cls`.\n * This function takes into account the multiple base classes.\n *\n * @param v The object to check.\n * @param cls The constructor of the class to check.\n * @return Whether or not the object `v` is an instance of the given class `cls`.\n */\nfunction isInstanceOf<T extends object, TBase extends Ctor> (v: T, cls: TBase): boolean {\n\tif (v instanceof cls) {\n\t\treturn true;\n\t}\n\t// @ts-ignore\n\tif (SymbolBases in v && Array.isArray(v[SymbolBases])) {\n\t\t// @ts-ignore\n\t\tfor (const base of v[SymbolBases]) {\n\t\t\tif (isInstanceOf(base, cls)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport {Ctor, InstancesArray, HasBasesArray, HasBases, bases, defineProperties, isInstanceOf, SymbolBases}\n"]}